"use strict";
class Strings {
	static toFixed(x, fractionDigits) { return x.toFixed(fractionDigits); }
	static init() {
		const language = (navigator["userLanguage"] || navigator.language);
		if (language && language.toLowerCase().indexOf("pt") === 0) {
			Strings.language = "pt-br";
			document.documentElement.setAttribute("lang", "pt-br");
			Strings.DecimalSeparator = ",";
			Strings.OppositeDecimalSeparator = ".";
			Strings.AntecedentEvaluation = "Avaliação de Antecedente";
			Strings.BiconditionalElimination = "Eliminação de Bicondicional";
			Strings.ConsequentEvaluation = "Avaliação de Consequente";
			Strings.ConstructiveDilemma = "Dilema Construtivo";
			Strings.DestructiveDilemma = "Dilema Destrutivo";
			Strings.DisjunctionElimination = "Eliminação de Disjunção";
			Strings.DisjunctiveSyllogism = "Silogismo Disjuntivo";
			Strings.HypotheticalSyllogism = "Silogismo Hipotético";
			Strings.ModusPonens = "Modus Ponens";
			Strings.ModusTollens = "Modus Tollens";
			Strings.NegationIntroduction = "Introdução de Negação";
			Strings.Simplification = "Simplificação";
			Strings.PleaseWait = "Por favor, aguarde\u2026";
			Strings.Error = "Erro";
			Strings.ICouldNotDeductAnythingElse = "Não consegui deduzir mais nada 😊";
			Strings.False = "Falso";
			Strings.True = "Verdadeiro";
			Strings.New = "Novo";
			Strings.Load = "Abrir";
			Strings.LoadEllipsis = "Abrir\u2026";
			Strings.Save = "Salvar";
			Strings.SaveEllipsis = "Salvar\u2026";
			Strings.LoadExample = "Abrir Exemplo";
			Strings.InstallEllipsis = "Instalar\u2026";
			Strings.WrapMode = "Quebra de Linha";
			Strings.Edit = "Edit";
			Strings.Delete = "Excluir";
			Strings.Enable = "Habilitar";
			Strings.Disable = "Desabilitar";
			Strings.Enabled = "Habilitado";
			Strings.Disabled = "Desabilitado";
			Strings.Cancel = "Cancelar";
			Strings.Clear = "Limpar";
			Strings.Back = "Voltar";
			Strings.Close = "Fechar";
			Strings.Refresh = "Recarregar";
			Strings.Exit = "Sair";
			Strings.ShowNextDeduction = "Mostrar Próxima Dedução";
			Strings.StopDeducting = "Parar Deduções";
			Strings.FileName = "Nome do Arquivo";
			Strings.UnknownError = "Erro desconhecido";
			Strings.Theme = "Tema";
			Strings.ThemeEllipsis = "Tema\u2026";
			Strings.BrowserNotSupported = "Infelizmente seu navegador não suporta essa funcionalidade 😢";
			Strings.UpdateAvailable = "Atualização Disponível!";
			Strings.PleaseRefresh = "Por favor, recarregue a página para atualizar a aplicação 😊";
			Strings.ConfirmQuit = "Deseja mesmo sair da página? Você perderá o documento atual.";
			Strings.ConfirmClose = "Deseja mesmo continuar? Você perderá as alterações não salvas.";
			Strings.ErrorNoFile = "Seu browser não oferece suporte a acesso avançado de arquivos 😢";
			Strings.ErrorFileLoad = "Ocorreu um erro ao ler o arquivo 😢";
			Strings.ErrorFileSave = "Ocorreu um erro ao gravar o arquivo 😢";
			Strings.ErrorDownload = "Ocorreu um erro durante o download dos dados 😢";
			Strings.ErrorInvalidFileName = "Nome de arquivo inválido 😢";
			Strings.ErrorInvalidChar = "Caractere inválido: ";
			Strings.ErrorUnexpectedEndOfCode = "Fim de código inesperado.";
			Strings.ErrorUnexpectedEndOfCodeUnaryExpected = "Fim de código inesperado. Era esperado uma variável, negação ou (.";
			Strings.ErrorUnexpectedEndOfLineUnaryExpected = "Término de linha inesperado. Era esperado uma variável, negação ou (.";
			Strings.ErrorEndOfLineExpected = "Término de linha inesperado.";
			Strings.ErrorUnexpectedOperatorUnaryExpected = "Operador inesperado. Era esperado uma variável, negação ou (.";
			Strings.ErrorUnaryExpected = "Caractere inválido encontrado. Era esperado uma variável, negação ou (.";
			Strings.ErrorClosingParenthesisExpected = "Era esperado um ).";
			Strings.ErrorClosingParenthesis2Expected = "Era esperado um ].";
			Strings.ErrorClosingParenthesis3Expected = "Era esperado um }.";
			Strings.ErrorClosingParenthesisOrOperatorExpected = "Era esperado um ) ou um operador de conjunção, disjunção, implicação ou bicondicional.";
			Strings.ErrorClosingParenthesis2OrOperatorExpected = "Era esperado um ] ou um operador de conjunção, disjunção, implicação ou bicondicional.";
			Strings.ErrorClosingParenthesis3OrOperatorExpected = "Era esperado um } ou um operador de conjunção, disjunção, implicação ou bicondicional.";
			Strings.ErrorConditionalOperatorExpected = "Era esperado operador de implicação ou bicondicional.";
			Strings.ErrorOperatorExpected = "Era esperado um operador de conjunção, disjunção, implicação ou bicondicional.";
			Strings.ErrorVariableAlreadyAssignedToADifferentValue = "Um valor diferente já havia sido atribuído à variável: ";
			Strings.ErrorExpressionAlreadyAssignedToADifferentValue = "Um valor diferente já havia sido atribuído à expressão: ";
			Strings.ErrorExpressionUsesTooManyVariables = "A expressão utiliza mais de 16 variáveis.";
			Strings.ErrorInconsistentAxioms = "Premissas inconsistentes: ";
			Strings.ErrorInconsistentExpression = "Expressão inconsistente: ";
			Strings.ErrorInconsistentExpression2 = " era avaliada como ";
			Strings.ErrorInconsistentExpression3because = " por causa de ";
			Strings.ErrorInconsistentExpression3 = " mas agora é avaliada como ";
			Strings.ErrorTooManyVariables = "Mais de 256 variáveis declaradas.";
			Strings.ErrorUnknownVariable = "Variável desconhecida: ";
		}
		Strings.translateChildren(document.body);
	}
	static translate(key) {
		const v = Strings[key];
		return (v !== undefined ? v : key);
	}
	;
	static translateChildren(parent) {
		const childNodes = parent.childNodes;
		for (let i = childNodes.length - 1; i >= 0; i--) {
			const c = childNodes[i];
			if (!c.tagName)
				continue;
			if (c.childNodes && c.childNodes.length)
				Strings.translateChildren(c);
			let d;
			if ((d = c.getAttribute("title")))
				c.setAttribute("title", Strings.translate(d));
			if (!(d = c.getAttribute("data-string")))
				continue;
			c.removeAttribute("data-string");
			let start = 0;
			do {
				let end = d.indexOf(";", start);
				if (end < start)
					end = d.length;
				const idx = d.indexOf("|", start);
				if (idx < 0 || idx >= end) {
					c.appendChild(document.createTextNode(Strings.translate(d)));
				}
				else {
					const attr = d.substring(start, idx), key = d.substring(idx + 1, end);
					if (attr == "text")
						c.appendChild(document.createTextNode(Strings.translate(key)));
					else
						c.setAttribute(attr, Strings.translate(key));
				}
				start = end + 1;
			} while (start < d.length);
		}
	}
}
Strings.language = "en";
Strings.DecimalSeparator = ".";
Strings.OppositeDecimalSeparator = ",";
Strings.Oops = "Oops\u2026";
Strings.AntecedentEvaluation = "Antecedent Evaluation";
Strings.BiconditionalElimination = "Biconditional Elimination";
Strings.ConsequentEvaluation = "Consequent Evaluation";
Strings.ConstructiveDilemma = "Constructive Dilemma";
Strings.DestructiveDilemma = "Destructive Dilemma";
Strings.DisjunctionElimination = "Disjunction Elimination";
Strings.DisjunctiveSyllogism = "Disjunctive Syllogism";
Strings.HypotheticalSyllogism = "Hypothetical Syllogism";
Strings.ModusPonens = "Modus Ponens";
Strings.ModusTollens = "Modus Tollens";
Strings.NegationIntroduction = "Negation Introduction";
Strings.Simplification = "Simplification";
Strings.PleaseWait = "Please wait\u2026";
Strings.Error = "Error";
Strings.ICouldNotDeductAnythingElse = "I could not deduct anything else 😊";
Strings.False = "False";
Strings.True = "True";
Strings.Ln = "Ln";
Strings.Col = "Col";
Strings.Menu = "Menu";
Strings.New = "New";
Strings.Load = "Load";
Strings.LoadEllipsis = "Load\u2026";
Strings.Save = "Save";
Strings.SaveEllipsis = "Save\u2026";
Strings.LoadExample = "Load Example";
Strings.InstallEllipsis = "Install\u2026";
Strings.WrapMode = "Line Wrap";
Strings.Edit = "Edit";
Strings.Delete = "Delete";
Strings.Enable = "Enable";
Strings.Disable = "Disable";
Strings.Enabled = "Enabled";
Strings.Disabled = "Disabled";
Strings.OK = "OK";
Strings.Cancel = "Cancel";
Strings.Clear = "Clear";
Strings.Back = "Back";
Strings.Close = "Close";
Strings.Refresh = "Refresh";
Strings.Exit = "Exit";
Strings.ShowNextDeduction = "Show Next Deduction";
Strings.StopDeducting = "Stop Deducting";
Strings.FileName = "File Name";
Strings.UnknownError = "Unknown error";
Strings.Theme = "Theme";
Strings.ThemeEllipsis = "Theme\u2026";
Strings.BrowserNotSupported = "Unfortunately, your browser does not support this feature 😢";
Strings.UpdateAvailable = "Update Available!";
Strings.PleaseRefresh = "Please, refresh the page to update the app 😊";
Strings.ConfirmQuit = "Do you really want to quit? You will lose unsaved information.";
Strings.ConfirmClose = "Do you really want to continue? You will lose unsaved information.";
Strings.ErrorNoFile = "Your browser does not support advanced file access 😢";
Strings.ErrorFileLoad = "An error occurred while reading the file 😢";
Strings.ErrorFileSave = "An error occurred while saving the file 😢";
Strings.ErrorDownload = "An error occurred while downloading data 😢";
Strings.ErrorInvalidFileName = "Invalid file name 😢";
Strings.ErrorInvalidChar = "Invalid character: ";
Strings.ErrorUnexpectedEndOfCode = "Unexpected end of code.";
Strings.ErrorUnexpectedEndOfCodeUnaryExpected = "Unexpected end of code. Variable, negation or ( expected.";
Strings.ErrorUnexpectedEndOfLineUnaryExpected = "Unexpected end of line. Variable, negation or ( expected.";
Strings.ErrorEndOfLineExpected = "End of line expected.";
Strings.ErrorUnexpectedOperatorUnaryExpected = "Unexpected operator. Variable, negation or ( expected.";
Strings.ErrorUnaryExpected = "Invalid character found. Variable, negation or ( expected.";
Strings.ErrorClosingParenthesisExpected = ") expected.";
Strings.ErrorClosingParenthesis2Expected = "] expected.";
Strings.ErrorClosingParenthesis3Expected = "} expected.";
Strings.ErrorClosingParenthesisOrOperatorExpected = "), conjunction, disjunction, implication or biconditional operator expected.";
Strings.ErrorClosingParenthesis2OrOperatorExpected = "], conjunction, disjunction, implication or biconditional operator expected.";
Strings.ErrorClosingParenthesis3OrOperatorExpected = "}, conjunction, disjunction, implication or biconditional operator expected.";
Strings.ErrorConditionalOperatorExpected = "Implication or biconditional operator expected.";
Strings.ErrorOperatorExpected = "Conjunction, disjunction, implication or biconditional operator expected.";
Strings.ErrorVariableAlreadyAssignedToADifferentValue = "Variable already assigned to a different value: ";
Strings.ErrorExpressionAlreadyAssignedToADifferentValue = "Expression already assigned to a different value: ";
Strings.ErrorExpressionUsesTooManyVariables = "Expression uses more than 16 variables.";
Strings.ErrorInconsistentAxioms = "Inconsistent axioms: ";
Strings.ErrorInconsistentExpression = "Inconsistent expression: ";
Strings.ErrorInconsistentExpression2 = " evaluated as ";
Strings.ErrorInconsistentExpression3because = " because of ";
Strings.ErrorInconsistentExpression3 = " but now evaluates as ";
Strings.ErrorTooManyVariables = "More than 256 declared variables.";
Strings.ErrorUnknownVariable = "Unknown variable: ";
class ModelObject {
}
class Evaluatable extends ModelObject {
	constructor(isUnary) {
		super();
		this.id = Evaluatable.nextId++;
		this.isUnary = isUnary;
		this._usedVariables = null;
		this._sortedVariables = null;
		this._equivalence = null;
		this._evaluatedValue = null;
		this.equivalenceVariableCount = 0;
		this.equivalenceLastByteMask = 0;
		this.computedSimplifiedString = null;
		this.computedString = null;
	}
	get simplifiedString() {
		if (!this.computedSimplifiedString)
			this.computedSimplifiedString = this.computeString(true);
		return this.computedSimplifiedString;
	}
	toString(simplified) {
		if (simplified) {
			return this.simplifiedString;
		}
		else {
			if (!this.computedString)
				this.computedString = this.computeString(false);
			return this.computedString;
		}
	}
	get usedVariables() {
		if (!this._usedVariables) {
			this._usedVariables = new VariableMap();
			this.collectVariables(this._usedVariables);
		}
		return this._usedVariables;
	}
	get sortedVariables() {
		if (!this._sortedVariables) {
			const usedVariables = this.usedVariables;
			const ids = [];
			for (let id of usedVariables.keys())
				ids.push(id);
			ids.sort((a, b) => (a - b));
			this._sortedVariables = ids.join("_");
		}
		return this._sortedVariables;
	}
	get equivalence() {
		if (!this._equivalence) {
			const usedVariables = this.usedVariables;
			const variables = [];
			for (let variable of usedVariables.values())
				variables.push(variable);
			variables.sort((a, b) => (a.id - b.id));
			const variableCount = variables.length;
			if (variableCount > 16)
				throw new Error(Strings.ErrorExpressionUsesTooManyVariables);
			const totalCombinations = 1 << variableCount, equivalence = new Uint8Array(variableCount + ((totalCombinations + 7) >>> 3));
			this.equivalenceVariableCount = variableCount;
			const validBitsInLastByte = (totalCombinations & 7) || 8;
			this.equivalenceLastByteMask = (1 << validBitsInLastByte) - 1;
			for (let i = 0; i < variableCount; i++)
				equivalence[i] = variables[i].id;
			for (let i = 0, bitIndex = (variableCount << 3); i < totalCombinations; i++, bitIndex++) {
				for (let v = variableCount - 1, tmp = i; v >= 0; v--, tmp >>>= 1)
					variables[v].helperValue = !!(tmp & 1);
				if (this.evaluateEquivalence())
					equivalence[(bitIndex >>> 3)] |= 1 << (bitIndex & 7);
			}
			this._equivalence = equivalence;
		}
		return this._equivalence;
	}
	isEquivalent(evaluatable) {
		const a = this.equivalence, b = (evaluatable = evaluatable.actualEvaluatable).equivalence;
		if (this.equivalenceVariableCount !== evaluatable.equivalenceVariableCount)
			return false;
		const length = a.length;
		for (let i = 0; i < length; i++) {
			if (a[i] !== b[i])
				return false;
		}
		return true;
	}
	isEquivalentNegated(evaluatable) {
		const a = this.equivalence, b = (evaluatable = evaluatable.actualEvaluatable).equivalence, equivalenceVariableCount = this.equivalenceVariableCount;
		if (equivalenceVariableCount !== evaluatable.equivalenceVariableCount)
			return false;
		let i = 0;
		for (; i < equivalenceVariableCount; i++) {
			if (a[i] !== b[i])
				return false;
		}
		const length = a.length - 1;
		for (; i < length; i++) {
			if (a[i] !== ~b[i])
				return false;
		}
		return (a[i] === ((~b[i]) & this.equivalenceLastByteMask));
	}
	isEquivalentSomehow(evaluatable) {
		const a = this.equivalence, b = (evaluatable = evaluatable.actualEvaluatable).equivalence, equivalenceVariableCount = this.equivalenceVariableCount;
		if (equivalenceVariableCount !== evaluatable.equivalenceVariableCount)
			return 0;
		let i = 0;
		for (; i < equivalenceVariableCount; i++) {
			if (a[i] !== b[i])
				return 0;
		}
		const length = a.length - 1;
		if (i === length)
			return ((a[i] === b[i]) ? 1 : ((a[i] === ((~b[i]) & this.equivalenceLastByteMask)) ? -1 : 0));
		if (a[i] === b[i]) {
			i++;
			for (; i <= length; i++) {
				if (a[i] !== b[i])
					return 0;
			}
			return 1;
		}
		else if (a[i] === ~b[i]) {
			i++;
			for (; i < length; i++) {
				if (a[i] !== ~b[i])
					return 0;
			}
			return ((a[i] === ((~b[i]) & this.equivalenceLastByteMask)) ? -1 : 0);
		}
		return 0;
	}
	evaluateValue() {
		const evaluatedValue = this.evaluateValueInternal();
		if (evaluatedValue !== null) {
			if (this._evaluatedValue === null)
				this._evaluatedValue = evaluatedValue;
			else if (evaluatedValue !== this._evaluatedValue)
				throw new Error(Strings.ErrorInconsistentExpression + this.toString() + Strings.ErrorInconsistentExpression2 + (this._evaluatedValue ? Strings.True : Strings.False) + Strings.ErrorInconsistentExpression3 + (evaluatedValue ? Strings.True : Strings.False));
		}
		return evaluatedValue;
	}
	get actualEvaluatable() {
		return this;
	}
}
Evaluatable.nextId = 1;
class SubExpression extends Evaluatable {
	constructor(evaluatable, openingParenthesis, closingParenthesis) {
		super(true);
		this.evaluatable = evaluatable.actualEvaluatable;
		this.openingParenthesis = openingParenthesis || TokenStrings.OpeningParenthesis;
		this.closingParenthesis = closingParenthesis || TokenStrings.ClosingParenthesis;
	}
	equals(o) {
		return ((o instanceof Evaluatable) && this.evaluatable.equals(o));
	}
	computeString(simplified) {
		return this.openingParenthesis + this.evaluatable.toString(simplified) + this.closingParenthesis;
	}
	checkIfAxiomIsOfInterest(axiom) {
		this.evaluatable.checkIfAxiomIsOfInterest(axiom);
	}
	collectVariables(usedVariables) {
		this.evaluatable.collectVariables(usedVariables);
	}
	evaluateEquivalence() {
		return this.evaluatable.evaluateEquivalence();
	}
	evaluateValueInternal() {
		return this.evaluatable.evaluateValue();
	}
	get usedVariables() {
		return this.evaluatable.usedVariables;
	}
	get sortedVariables() {
		return this.evaluatable.sortedVariables;
	}
	get equivalence() {
		return this.evaluatable.equivalence;
	}
	isEquivalent(evaluatable) {
		return this.evaluatable.isEquivalent(evaluatable);
	}
	isEquivalentNegated(evaluatable) {
		return this.evaluatable.isEquivalentNegated(evaluatable);
	}
	isEquivalentSomehow(evaluatable) {
		return this.evaluatable.isEquivalentSomehow(evaluatable);
	}
	evaluateValue() {
		return this.evaluatable.evaluateValue();
	}
	get actualEvaluatable() {
		return this.evaluatable;
	}
}
class Variable extends Evaluatable {
	constructor(id, name) {
		super(true);
		this.id = id;
		this.name = name;
		this.helperValue = false;
		this.assignedValue = null;
	}
	equals(o) {
		return (this === o);
	}
	get simplifiedString() {
		return this.name;
	}
	toString(simplified) {
		return this.name;
	}
	computeString(simplified) {
		return this.name;
	}
	checkIfAxiomIsOfInterest(axiom) {
		switch (axiom.evaluatable.isEquivalentSomehow(this)) {
			case 1:
				if (this.assignedValue === null)
					this.assignedValue = true;
				else if (!this.assignedValue)
					throw new Error(Strings.ErrorVariableAlreadyAssignedToADifferentValue + Strings.False);
				break;
			case -1:
				if (this.assignedValue === null)
					this.assignedValue = false;
				else if (this.assignedValue)
					throw new Error(Strings.ErrorVariableAlreadyAssignedToADifferentValue + Strings.True);
				break;
		}
	}
	collectVariables(usedVariables) {
		usedVariables.set(this.id, this);
	}
	evaluateEquivalence() {
		return this.helperValue;
	}
	evaluateValueInternal() {
		return this.assignedValue;
	}
}
class IdSet extends Set {
	intersects(subset) {
		if (subset.size <= this.size) {
			for (let id of subset.keys()) {
				if (this.has(id))
					return true;
			}
		}
		else {
			for (let id of this.keys()) {
				if (subset.has(id))
					return true;
			}
		}
		return false;
	}
	containsSameElements(subset) {
		if (this.size !== subset.size)
			return false;
		for (let id of subset.keys()) {
			if (!this.has(id))
				return false;
		}
		return true;
	}
	containsSubset(subset) {
		if (this.size < subset.size)
			return false;
		for (let id of subset.keys()) {
			if (!this.has(id))
				return false;
		}
		return true;
	}
	deleteSubset(subset) {
		for (let id of subset.keys())
			this.delete(id);
	}
	addSubset(subset) {
		for (let id of subset.keys())
			this.add(id);
	}
	clone() {
		return new IdSet(this);
	}
}
class VariableMap extends Map {
	intersects(subset) {
		if (subset.size <= this.size) {
			for (let id of subset.keys()) {
				if (this.has(id))
					return true;
			}
		}
		else {
			for (let id of this.keys()) {
				if (subset.has(id))
					return true;
			}
		}
		return false;
	}
	containsSameElements(subset) {
		if (this.size !== subset.size)
			return false;
		for (let id of subset.keys()) {
			if (!this.has(id))
				return false;
		}
		return true;
	}
	containsSubset(subset) {
		if (this.size < subset.size)
			return false;
		for (let id of subset.keys()) {
			if (!this.has(id))
				return false;
		}
		return true;
	}
	deleteSubset(subset) {
		for (let id of subset.keys())
			this.delete(id);
	}
	clone() {
		return new VariableMap(this);
	}
	createIdSet() {
		return new IdSet(this.keys());
	}
}
function createVariableNameMap() {
	return new Map();
}
function createAxiomMap() {
	return new Map();
}
function createAxiomOfInterestMap() {
	return new Map();
}
function createBooleanMap() {
	return new Map();
}
function createRuleMap() {
	return new Map();
}
class VariableCollection {
	constructor() {
		this.variables = createVariableNameMap();
		this.nextVariableId = 0;
	}
	getOrCreateVariable(name) {
		let variable = this.variables.get(name);
		if (variable)
			return variable;
		if (this.nextVariableId >= 256)
			throw new Error(Strings.ErrorTooManyVariables);
		variable = new Variable(this.nextVariableId++, name);
		this.variables.set(name, variable);
		return variable;
	}
	getVariable(name) {
		return (this.variables.get(name) || null);
	}
}
class Axiom extends ModelObject {
	constructor(id, evaluatable) {
		super();
		this.id = id;
		this.evaluatable = evaluatable.actualEvaluatable;
	}
	get simplifiedString() {
		return this.evaluatable.simplifiedString;
	}
	toString(simplified) {
		return this.evaluatable.toString(simplified);
	}
	equals(o) {
		return ((o instanceof Axiom) && o.evaluatable.equals(this.evaluatable));
	}
	initialize(axiomIndex, axioms) {
		let r = true;
		for (let i = 0; i < axiomIndex; i++) {
			switch (this.evaluatable.isEquivalentSomehow(axioms[i].evaluatable)) {
				case 1:
					r = false;
					break;
				case 0:
					break;
				case -1:
					throw new Error(Strings.ErrorInconsistentAxioms + this.id + " / " + axioms[i].id);
			}
		}
		return r;
	}
	checkIfAxiomIsOfInterest(axiom) {
		this.evaluatable.checkIfAxiomIsOfInterest(axiom);
		axiom.evaluatable.checkIfAxiomIsOfInterest(this);
	}
}
class Rule {
	constructor(name, inputCount) {
		if (inputCount > 3)
			throw new Error("Invalid input count: " + inputCount);
		this.id = Rule.nextIds[inputCount - 1]++;
		this.name = name;
		this.inputCount = inputCount;
	}
	static init() {
		Rule.biconditionalElimination = new BiconditionalElimination();
		Rule.rules.push(new Simplification());
		Rule.rules.push(new AntecedentEvaluation());
		Rule.rules.push(new ConsequentEvaluation());
		Rule.rules2.push(new DisjunctiveSyllogism());
		Rule.rules2.push(new HypotheticalSyllogism());
		Rule.rules2.push(new ModusPonens());
		Rule.rules2.push(new ModusTollens());
		Rule.rules2.push(new NegationIntroduction());
		Rule.rules3.push(new ConstructiveDilemmaDisjunctionElimination());
		Rule.rules3.push(new DestructiveDilemma());
	}
	static applyRules(pendingDeductions, deductions, axiomIndex, axioms) {
		const lastAxiom = axioms[axiomIndex];
		let rules = Rule.rules;
		for (let i = rules.length - 1; i >= 0; i--) {
			const result = rules[i].apply(lastAxiom);
			if (result) {
				if (result === true)
					pendingDeductions.push({
						rule: rules[i],
						axioms: [lastAxiom]
					});
				else
					deductions.push.apply(deductions, result);
			}
		}
		rules = Rule.rules2;
		for (let i = 0; i < axiomIndex; i++) {
			const axiom = axioms[i];
			for (let j = rules.length - 1; j >= 0; j--) {
				const result = rules[j].apply(axiom, lastAxiom);
				if (result) {
					if (result === true)
						pendingDeductions.push({
							rule: rules[j],
							axioms: [axiom, lastAxiom]
						});
					else
						deductions.push.apply(deductions, result);
				}
			}
		}
		rules = Rule.rules3;
		for (let i = 0; i < axiomIndex; i++) {
			const axiom = axioms[i];
			for (let j = i + 1; j < axiomIndex; j++) {
				const axiom2 = axioms[j];
				for (let k = rules.length - 1; k >= 0; k--) {
					const result = rules[k].apply(axiom, axiom2, lastAxiom);
					if (result) {
						if (result === true)
							pendingDeductions.push({
								rule: rules[k],
								axioms: [axiom, axiom2, lastAxiom]
							});
						else
							deductions.push.apply(deductions, result);
					}
				}
			}
		}
	}
	static applyRulesOfPendingDeductions(pendingDeductions, deductions) {
		let pendingDeductionsLength = pendingDeductions.length;
		for (let i = 0; i < pendingDeductionsLength; i++) {
			const pendingDeduction = pendingDeductions[i], rule = pendingDeduction.rule, result = rule.apply.apply(rule, pendingDeduction.axioms);
			if (result !== true) {
				pendingDeductions.splice(i, 1);
				pendingDeductionsLength--;
				i--;
				if (result)
					deductions.push.apply(deductions, result);
			}
		}
	}
	toString() {
		return this.name;
	}
	createFullExplanation(name, a, b, c) {
		let explanation = name + ": " + a.id;
		if (b) {
			explanation += ", " + b.id;
			if (c)
				explanation += ", " + c.id;
		}
		return explanation;
	}
	createExplanation(a, b, c) {
		return this.createFullExplanation(this.name, a, b, c);
	}
}
Rule.rules = [];
Rule.rules2 = [];
Rule.rules3 = [];
Rule.nextIds = [0, 0, 0];
class AntecedentEvaluation extends Rule {
	constructor() {
		super(Strings.AntecedentEvaluation, 1);
	}
	apply(a) {
		const ea = a.evaluatable;
		if (ea instanceof Implication) {
			let v = ea.operandA.evaluateValue();
			if (v === null)
				return true;
			if (v === false)
				return false;
			return [
				{
					newEvaluatable: ea.operandA,
					explanation: this.createExplanation(a)
				}
			];
		}
		return false;
	}
}
class BiconditionalElimination extends Rule {
	constructor() {
		super(Strings.BiconditionalElimination, 1);
	}
	apply(a) {
		const ea = a.evaluatable;
		if (!(ea instanceof Biconditional))
			return false;
		const explanation = this.createExplanation(a);
		return [
			{
				newEvaluatable: new Implication(ea.operandA, ea.operandB),
				explanation
			},
			{
				newEvaluatable: new Implication(ea.operandB, ea.operandA),
				explanation
			}
		];
	}
}
class ConsequentEvaluation extends Rule {
	constructor() {
		super(Strings.ConsequentEvaluation, 1);
	}
	apply(a) {
		const ea = a.evaluatable;
		if (ea instanceof Implication) {
			let v = ea.operandB.evaluateValue();
			if (v === null)
				return true;
			if (v === true)
				return false;
			return [
				{
					newEvaluatable: new Negation(ea.operandB),
					explanation: this.createExplanation(a)
				}
			];
		}
		return false;
	}
}
class ConstructiveDilemmaDisjunctionElimination extends Rule {
	constructor() {
		super(Strings.ConstructiveDilemma, 3);
	}
	applyIfPossible(a, b, c) {
		const ea = a.evaluatable, eb = b.evaluatable, ec = c.evaluatable;
		let newEvaluatable;
		return (((ea instanceof Implication) && (eb instanceof Implication) && ec.isEquivalent(Disjunction.create([ea.operandA, eb.operandA]))) ?
			[
				{
					newEvaluatable: (newEvaluatable = Disjunction.create([ea.operandB, eb.operandB])),
					explanation: this.createFullExplanation((newEvaluatable instanceof Disjunction) ? Strings.ConstructiveDilemma : Strings.DisjunctionElimination, a, b, c)
				}
			]
			:
				false);
	}
	apply(a, b, c) {
		return this.applyIfPossible(a, b, c) ||
			this.applyIfPossible(a, c, b) ||
			this.applyIfPossible(b, c, a);
	}
}
class DestructiveDilemma extends Rule {
	constructor() {
		super(Strings.DestructiveDilemma, 3);
	}
	applyIfPossible(a, b, c) {
		const ea = a.evaluatable, eb = b.evaluatable, ec = c.evaluatable;
		return (((ea instanceof Implication) && (eb instanceof Implication) && ec.isEquivalent(Disjunction.create([new Negation(ea.operandB), new Negation(eb.operandB)]))) ?
			[
				{
					newEvaluatable: Disjunction.create([new Negation(ea.operandA), new Negation(eb.operandA)]),
					explanation: this.createExplanation(a, b, c)
				}
			]
			:
				false);
	}
	apply(a, b, c) {
		return this.applyIfPossible(a, b, c) ||
			this.applyIfPossible(a, c, b) ||
			this.applyIfPossible(b, c, a);
	}
}
class DisjunctiveSyllogism extends Rule {
	constructor() {
		super(Strings.DisjunctiveSyllogism, 2);
	}
	applyIfPossible(a, b) {
		const ea = a.evaluatable;
		let axiomOfInterest;
		if ((ea instanceof Disjunction) && (axiomOfInterest = ea.getAxiomOfInterest(b))) {
			if (axiomOfInterest.equivalence > -1)
				return false;
			const newOperands = ea.operands.slice(), axiomOfInterestOperands = axiomOfInterest.operands;
			for (let i = newOperands.length - 1; i >= 0; i--) {
				const newOperand = newOperands[i];
				for (let j = axiomOfInterestOperands.length - 1; j >= 0; j--) {
					if (newOperand === axiomOfInterestOperands[j]) {
						newOperands.splice(i, 1);
						break;
					}
				}
			}
			return [
				{
					newEvaluatable: ((newOperands.length === 1) ? newOperands[0] : Disjunction.create(newOperands)),
					explanation: this.createExplanation(a, b)
				}
			];
		}
		return false;
	}
	apply(a, b) {
		return this.applyIfPossible(a, b) || this.applyIfPossible(b, a);
	}
}
class HypotheticalSyllogism extends Rule {
	constructor() {
		super(Strings.HypotheticalSyllogism, 2);
	}
	applyIfPossible(a, b) {
		const ea = a.evaluatable, eb = b.evaluatable;
		return (((ea instanceof Implication) && (eb instanceof Implication) && ea.operandB.isEquivalent(eb.operandA)) ?
			[
				{
					newEvaluatable: new Implication(ea.operandA, eb.operandB),
					explanation: this.createExplanation(a, b)
				}
			]
			:
				false);
	}
	apply(a, b) {
		return this.applyIfPossible(a, b) || this.applyIfPossible(b, a);
	}
}
class ModusPonens extends Rule {
	constructor() {
		super(Strings.ModusPonens, 2);
	}
	applyIfPossible(a, b) {
		const ea = a.evaluatable, eb = b.evaluatable;
		return (((ea instanceof Implication) && ea.operandA.isEquivalent(eb)) ?
			[
				{
					newEvaluatable: ea.operandB,
					explanation: this.createExplanation(a, b)
				}
			]
			:
				false);
	}
	apply(a, b) {
		return this.applyIfPossible(a, b) || this.applyIfPossible(b, a);
	}
}
class ModusTollens extends Rule {
	constructor() {
		super(Strings.ModusTollens, 2);
	}
	applyIfPossible(a, b) {
		const ea = a.evaluatable, eb = b.evaluatable;
		return (((ea instanceof Implication) && ea.operandB.isEquivalentNegated(eb)) ?
			[
				{
					newEvaluatable: new Negation(ea.operandA),
					explanation: this.createExplanation(a, b)
				}
			]
			:
				false);
	}
	apply(a, b) {
		return this.applyIfPossible(a, b) || this.applyIfPossible(b, a);
	}
}
class NegationIntroduction extends Rule {
	constructor() {
		super(Strings.NegationIntroduction, 2);
	}
	apply(a, b) {
		const ea = a.evaluatable, eb = b.evaluatable;
		return (((ea instanceof Implication) && (eb instanceof Implication) && ea.operandA.isEquivalent(eb.operandA) && ea.operandB.isEquivalentNegated(eb.operandB)) ?
			[
				{
					newEvaluatable: new Negation(ea.operandA),
					explanation: this.createExplanation(a, b)
				}
			]
			:
				false);
	}
}
class Simplification extends Rule {
	constructor() {
		super(Strings.Simplification, 1);
	}
	apply(a) {
		const ea = a.evaluatable;
		if (!(ea instanceof Conjunction))
			return false;
		const operands = ea.operands, deductions = new Array(operands.length), explanation = this.createExplanation(a);
		for (let i = operands.length - 1; i >= 0; i--)
			deductions[i] = {
				newEvaluatable: operands[i],
				explanation
			};
		return deductions;
	}
}
class AxiomContext {
	constructor(code, variables, axioms, nextAxiomId) {
		this.code = code;
		this.variables = variables;
		this.axioms = axioms;
		this.nextAxiomId = nextAxiomId;
		this.deductions = null;
		this.pendingDeductions = [];
		this.stringDeductions = [];
		this.error = false;
	}
	getVariable(name) {
		return this.variables.getVariable(name);
	}
	step() {
		const pendingDeductions = this.pendingDeductions, stringDeductions = this.stringDeductions;
		if (!this.error) {
			try {
				const axioms = this.axioms;
				if (!this.deductions) {
					this.deductions = [];
					const deductions = this.deductions;
					let axiomsLength = axioms.length;
					for (let i = 0; i < axiomsLength; i++) {
						const result = Rule.biconditionalElimination.apply(axioms[i]);
						if (result && result !== true) {
							axioms.splice(i, 1);
							axiomsLength--;
							i--;
							deductions.push.apply(deductions, result);
						}
					}
					axiomsLength = axioms.length;
					for (let i = 0; i < axiomsLength; i++)
						axioms[i].initialize(i, axioms);
					for (let i = 0; i < axiomsLength; i++) {
						const axiom = axioms[i];
						for (let j = i + 1; j < axiomsLength; j++)
							axioms[j].checkIfAxiomIsOfInterest(axiom);
					}
					for (let i = 0; i < axiomsLength; i++)
						Rule.applyRules(pendingDeductions, deductions, i, axioms);
				}
				if (!stringDeductions.length) {
					const deductions = this.deductions;
					while (!stringDeductions.length && deductions.length) {
						const deduction = deductions.splice(0, 1)[0];
						if (deduction.error) {
							this.error = true;
							stringDeductions.push({
								error: true,
								text: deduction.explanation,
								explanation: null
							});
							break;
						}
						const previousAxiomsLength = axioms.length, axiom = new Axiom(this.nextAxiomId, deduction.newEvaluatable);
						try {
							if (!axiom.initialize(previousAxiomsLength, axioms))
								continue;
						}
						catch (ex) {
							stringDeductions.push({
								error: false,
								text: deduction.newEvaluatable.actualEvaluatable.toString(),
								explanation: deduction.explanation
							});
							throw ex;
						}
						axioms.push(axiom);
						this.nextAxiomId += 2;
						stringDeductions.push({
							error: false,
							text: deduction.newEvaluatable.actualEvaluatable.toString(),
							explanation: deduction.explanation
						});
						try {
							for (let i = 0; i < previousAxiomsLength; i++)
								axiom.checkIfAxiomIsOfInterest(axioms[i]);
							Rule.applyRulesOfPendingDeductions(pendingDeductions, deductions);
							Rule.applyRules(pendingDeductions, deductions, previousAxiomsLength, axioms);
						}
						catch (ex) {
							deductions.push({
								error: true,
								newEvaluatable: null,
								explanation: (("formatMessage" in ex) ? ex.formatMessage() : (ex.message || ex.toString()))
							});
							break;
						}
					}
				}
			}
			catch (ex) {
				this.error = true;
				stringDeductions.push({
					error: true,
					text: (("formatMessage" in ex) ? ex.formatMessage() : (ex.message || ex.toString())),
					explanation: null
				});
			}
		}
		return (stringDeductions.length ? stringDeductions.splice(0, 1)[0] : null);
	}
}
class InterpreterError extends Error {
	constructor(message, index, line, lineIndex) {
		super(message);
		this.index = index;
		this.line = line;
		this.lineIndex = lineIndex;
	}
	formatMessage() {
		return Strings.Ln + " " + this.line + ", " + Strings.Col + " " + this.lineIndex + " - " + this.message;
	}
}
class TokenStrings {
}
TokenStrings.OpeningParenthesis = "(";
TokenStrings.OpeningParenthesis2 = "[";
TokenStrings.OpeningParenthesis3 = "{";
TokenStrings.ClosingParenthesis = ")";
TokenStrings.ClosingParenthesis2 = "]";
TokenStrings.ClosingParenthesis3 = "}";
TokenStrings.Negation = "¬";
TokenStrings.Conjunction = "∧";
TokenStrings.ConjunctionSpace = " ∧ ";
TokenStrings.Disjunction = "∨";
TokenStrings.DisjunctionSpace = " ∨ ";
TokenStrings.Implication = "→";
TokenStrings.ImplicationSpace = " → ";
TokenStrings.Biconditional = "↔";
TokenStrings.BiconditionalSpace = " ↔ ";
TokenStrings.EndOfLine = "\n";
var TokenType;
(function (TokenType) {
	TokenType[TokenType["Variable"] = 0] = "Variable";
	TokenType[TokenType["OpeningParenthesis"] = 1] = "OpeningParenthesis";
	TokenType[TokenType["OpeningParenthesis2"] = 2] = "OpeningParenthesis2";
	TokenType[TokenType["OpeningParenthesis3"] = 3] = "OpeningParenthesis3";
	TokenType[TokenType["ClosingParenthesis"] = 4] = "ClosingParenthesis";
	TokenType[TokenType["ClosingParenthesis2"] = 5] = "ClosingParenthesis2";
	TokenType[TokenType["ClosingParenthesis3"] = 6] = "ClosingParenthesis3";
	TokenType[TokenType["Negation"] = 7] = "Negation";
	TokenType[TokenType["Conjunction"] = 8] = "Conjunction";
	TokenType[TokenType["Disjunction"] = 9] = "Disjunction";
	TokenType[TokenType["Implication"] = 10] = "Implication";
	TokenType[TokenType["Biconditional"] = 11] = "Biconditional";
	TokenType[TokenType["EndOfLine"] = 12] = "EndOfLine";
})(TokenType || (TokenType = {}));
class Token extends ModelObject {
	constructor(type, text, index, line, lineIndex) {
		super();
		this.type = type;
		this.text = text;
		this.index = index;
		this.line = line;
		this.lineIndex = lineIndex;
	}
	get isOperator() {
		switch (this.type) {
			case TokenType.Conjunction:
			case TokenType.Disjunction:
			case TokenType.Implication:
			case TokenType.Biconditional:
				return true;
		}
		return false;
	}
	get isExpressionOperator() {
		switch (this.type) {
			case TokenType.Conjunction:
			case TokenType.Disjunction:
				return true;
		}
		return false;
	}
	get isConditionalOperator() {
		switch (this.type) {
			case TokenType.Implication:
			case TokenType.Biconditional:
				return true;
		}
		return false;
	}
	get simplifiedString() {
		return this.text;
	}
	toString(simplified) {
		return this.text;
	}
	equals(o) {
		return ((o && (o instanceof Token) && o.type === this.type) ?
			((o.type === TokenType.Variable) ? (o.text === this.text) : true) :
			false);
	}
}
class TokenStream {
	constructor(code) {
		this.code = code;
		this.index = 0;
		this.line = 1;
		this.lineIndex = 1;
		this.token = this.fetchNextToken();
	}
	get currentIndex() {
		return this.index;
	}
	get currentLine() {
		return this.line;
	}
	get currentLineIndex() {
		return this.lineIndex;
	}
	peekToken() {
		return this.token;
	}
	getToken() {
		const token = this.token;
		this.token = this.fetchNextToken();
		return token;
	}
	fetchNextToken() {
		const code = this.code;
		if (this.index >= code.length)
			return null;
		let t;
		MainLoop: while (this.index < code.length) {
			const i = this.index;
			let c = code.charCodeAt(i);
			switch (c) {
				case 0x0020:
				case 0x0009:
				case 0x000B:
				case 0x000C:
				case 0x00A0:
					this.index++;
					this.lineIndex++;
					break;
				case 0x000A:
					this.index++;
					if ((i + 1) < code.length && code.charCodeAt(i + 1) === 0x000D)
						this.index++;
					t = new Token(TokenType.EndOfLine, TokenStrings.EndOfLine, i, this.line, this.lineIndex);
					this.line++;
					this.lineIndex = 1;
					return t;
				case 0x000D:
					this.index++;
					if ((i + 1) < code.length && code.charCodeAt(i + 1) === 0x000A)
						this.index++;
					t = new Token(TokenType.EndOfLine, TokenStrings.EndOfLine, i, this.line, this.lineIndex);
					this.line++;
					this.lineIndex = 1;
					return t;
				case 0x0085:
				case 0x2028:
				case 0x2029:
					t = new Token(TokenType.EndOfLine, TokenStrings.EndOfLine, i, this.line, this.lineIndex);
					this.index++;
					this.line++;
					this.lineIndex = 1;
					return t;
				case 0x0028:
					t = new Token(TokenType.OpeningParenthesis, TokenStrings.OpeningParenthesis, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x005B:
					t = new Token(TokenType.OpeningParenthesis2, TokenStrings.OpeningParenthesis2, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x007B:
					t = new Token(TokenType.OpeningParenthesis3, TokenStrings.OpeningParenthesis3, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x0029:
					t = new Token(TokenType.ClosingParenthesis, TokenStrings.ClosingParenthesis, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x005D:
					t = new Token(TokenType.ClosingParenthesis2, TokenStrings.ClosingParenthesis2, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x007D:
					t = new Token(TokenType.ClosingParenthesis3, TokenStrings.ClosingParenthesis3, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x007E:
				case 0x002D:
				case 0x00AC:
					t = new Token(TokenType.Negation, TokenStrings.Negation, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x005E:
				case 0x0026:
				case 0x002E:
				case 0x2227:
				case 0x22C5:
					t = new Token(TokenType.Conjunction, TokenStrings.Conjunction, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x0076:
				case 0x007C:
				case 0x2228:
					t = new Token(TokenType.Disjunction, TokenStrings.Disjunction, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x003E:
				case 0x2192:
				case 0x2283:
					t = new Token(TokenType.Implication, TokenStrings.Implication, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x003D:
				case 0x2194:
				case 0x2261:
					t = new Token(TokenType.Biconditional, TokenStrings.Biconditional, i, this.line, this.lineIndex);
					this.index++;
					this.lineIndex++;
					return t;
				case 0x0023:
					this.index++;
					this.lineIndex++;
					while (this.index < code.length) {
						c = code.charCodeAt(this.index);
						if (c === 0x000A || c === 0x000D)
							break;
						this.index++;
						this.lineIndex++;
					}
					break;
				default:
					const lineIndex = this.lineIndex;
					let length = 0;
					while (this.index < code.length) {
						c = code.charCodeAt(this.index);
						if (c !== 0x005F && (c < 0x0030 || (c > 0x0039 && c < 0x0041) || (c > 0x005A && c < 0x0061) || c > 0x007A)) {
							if (!length)
								throw new InterpreterError(Strings.ErrorInvalidChar + String.fromCharCode(c), i, this.line, lineIndex);
							return new Token(TokenType.Variable, code.substr(i, length), i, this.line, lineIndex);
						}
						length++;
						this.index++;
						this.lineIndex++;
					}
					if (length)
						return new Token(TokenType.Variable, code.substr(i, length), i, this.line, lineIndex);
					break;
			}
		}
		return null;
	}
}
class Parser {
	static parse(code) {
		Evaluatable.nextId = 1;
		const tokenStream = new TokenStream(code);
		let axiom = null;
		const variables = new VariableCollection(), axioms = [];
		for (;;) {
			let t = tokenStream.peekToken();
			if (!t)
				break;
			if (t.type === TokenType.EndOfLine) {
				tokenStream.getToken();
				continue;
			}
			axiom = Parser.parseAxiom(t.line, tokenStream, variables);
			if (!axiom)
				break;
			axioms.push(axiom);
		}
		return new AxiomContext(code, variables, axioms, tokenStream.currentLine + 3);
	}
	static parseUnary(tokenStream, variables, axiomContext) {
		const token = tokenStream.getToken();
		if (!token)
			throw new InterpreterError(Strings.ErrorUnexpectedEndOfCodeUnaryExpected, tokenStream.currentIndex, tokenStream.currentLine, tokenStream.currentLineIndex);
		let evaluatable;
		switch (token.type) {
			case TokenType.Variable:
				let variable = null;
				if (variables)
					variable = variables.getOrCreateVariable(token.text);
				else if (axiomContext)
					variable = axiomContext.getVariable(token.text);
				if (!variable)
					throw new InterpreterError(Strings.ErrorUnknownVariable + token.text, token.index, token.line, token.lineIndex);
				return variable;
			case TokenType.OpeningParenthesis:
				evaluatable = Parser.parseConditional(tokenStream, variables, axiomContext);
				const closingParenthesis = tokenStream.getToken();
				if (!closingParenthesis)
					throw new InterpreterError(Strings.ErrorClosingParenthesisOrOperatorExpected, tokenStream.currentIndex, tokenStream.currentLine, tokenStream.currentLineIndex);
				if (closingParenthesis.type !== TokenType.ClosingParenthesis)
					throw new InterpreterError(Strings.ErrorClosingParenthesisOrOperatorExpected, closingParenthesis.index, closingParenthesis.line, closingParenthesis.lineIndex);
				return (evaluatable.isUnary ? evaluatable : new SubExpression(evaluatable));
			case TokenType.OpeningParenthesis2:
				evaluatable = Parser.parseConditional(tokenStream, variables, axiomContext);
				const closingParenthesis2 = tokenStream.getToken();
				if (!closingParenthesis2)
					throw new InterpreterError(Strings.ErrorClosingParenthesis2OrOperatorExpected, tokenStream.currentIndex, tokenStream.currentLine, tokenStream.currentLineIndex);
				if (closingParenthesis2.type !== TokenType.ClosingParenthesis2)
					throw new InterpreterError(Strings.ErrorClosingParenthesis2OrOperatorExpected, closingParenthesis2.index, closingParenthesis2.line, closingParenthesis2.lineIndex);
				return (evaluatable.isUnary ? evaluatable : new SubExpression(evaluatable, TokenStrings.OpeningParenthesis2, TokenStrings.ClosingParenthesis2));
			case TokenType.OpeningParenthesis3:
				evaluatable = Parser.parseConditional(tokenStream, variables, axiomContext);
				const closingParenthesis3 = tokenStream.getToken();
				if (!closingParenthesis3)
					throw new InterpreterError(Strings.ErrorClosingParenthesis3OrOperatorExpected, tokenStream.currentIndex, tokenStream.currentLine, tokenStream.currentLineIndex);
				if (closingParenthesis3.type !== TokenType.ClosingParenthesis3)
					throw new InterpreterError(Strings.ErrorClosingParenthesis3OrOperatorExpected, closingParenthesis3.index, closingParenthesis3.line, closingParenthesis3.lineIndex);
				return (evaluatable.isUnary ? evaluatable : new SubExpression(evaluatable, TokenStrings.OpeningParenthesis3, TokenStrings.ClosingParenthesis3));
			case TokenType.Negation:
				evaluatable = Parser.parseUnary(tokenStream, variables, axiomContext);
				return new Negation(evaluatable);
			case TokenType.EndOfLine:
				throw new InterpreterError(Strings.ErrorUnexpectedEndOfLineUnaryExpected, token.index, token.line, token.lineIndex);
			default:
				throw new InterpreterError(token.isOperator ? Strings.ErrorUnexpectedOperatorUnaryExpected : Strings.ErrorUnaryExpected, token.index, token.line, token.lineIndex);
		}
	}
	static parseExpression(tokenStream, variables, axiomContext) {
		let operand = Parser.parseUnary(tokenStream, variables, axiomContext), token = tokenStream.peekToken();
		if (!token || !token.isExpressionOperator)
			return operand;
		let lastOperator = token.type, operands = [operand];
		while (token && token.isExpressionOperator) {
			tokenStream.getToken();
			if (token.type !== lastOperator) {
				operands = [((lastOperator === TokenType.Conjunction) ? Conjunction.create(operands) : Disjunction.create(operands))];
				lastOperator = token.type;
			}
			operands.push(Parser.parseUnary(tokenStream, variables, axiomContext));
			token = tokenStream.peekToken();
		}
		return ((lastOperator === TokenType.Conjunction) ? Conjunction.create(operands) : Disjunction.create(operands));
	}
	static parseConditional(tokenStream, variables, axiomContext) {
		let operand = Parser.parseExpression(tokenStream, variables, axiomContext), token = tokenStream.peekToken();
		while (token && token.isConditionalOperator) {
			tokenStream.getToken();
			const operandB = Parser.parseExpression(tokenStream, variables, axiomContext);
			operand = ((token.type === TokenType.Implication) ? new Implication(operand, operandB) : new Biconditional(operand, operandB));
			token = tokenStream.peekToken();
		}
		return operand;
	}
	static parseAxiom(id, tokenStream, variables, axiomContext) {
		const evaluatable = Parser.parseConditional(tokenStream, variables, axiomContext);
		const token = tokenStream.peekToken();
		if (token && token.type !== TokenType.EndOfLine)
			throw new InterpreterError(Strings.ErrorEndOfLineExpected, token.index, token.line, token.lineIndex);
		return new Axiom(id, evaluatable);
	}
}
class Connective extends Evaluatable {
	constructor(operands, skipSort, connector, clazz) {
		super(false);
		this.originalOperands = operands;
		this.connector = connector;
		this.axiomsOfInterest = createAxiomOfInterestMap();
		if (skipSort) {
			this.operands = operands;
		}
		else {
			const actualOperands = [];
			for (let i = operands.length - 1; i >= 0; i--) {
				const operand = operands[i];
				if (operand.actualEvaluatable instanceof clazz) {
					const newOperands = operand.actualEvaluatable.operands;
					for (let j = newOperands.length - 1; j >= 0; j--) {
						const newOperand = newOperands[j];
						actualOperands.push(newOperand.isUnary ? newOperand : new SubExpression(newOperand));
					}
				}
				else {
					actualOperands.push(operand.isUnary ? operand : new SubExpression(operand));
				}
			}
			for (let i = actualOperands.length - 1; i >= 0; i--) {
				const operand = actualOperands[i].actualEvaluatable;
				for (let j = i - 1; j >= 0; j--) {
					if (operand.equals(actualOperands[j])) {
						actualOperands.splice(i, 1);
						break;
					}
				}
			}
			const sortedOperands = new Array(actualOperands.length);
			for (let i = sortedOperands.length - 1; i >= 0; i--)
				sortedOperands[i] = {
					sortedVariables: actualOperands[i].actualEvaluatable.sortedVariables,
					operand: actualOperands[i]
				};
			sortedOperands.sort((a, b) => ((a.sortedVariables < b.sortedVariables) ? -1 : 1));
			for (let i = sortedOperands.length - 2; i >= 0; i--) {
				if (sortedOperands[i].sortedVariables !== sortedOperands[i + 1].sortedVariables ||
					!sortedOperands[i].operand.isEquivalent(sortedOperands[i + 1].operand))
					continue;
				sortedOperands.splice(i + 1, 1);
			}
			this.operands = new Array(sortedOperands.length);
			for (let i = sortedOperands.length - 1; i >= 0; i--)
				this.operands[i] = sortedOperands[i].operand;
		}
	}
	equals(o) {
		if (!(o instanceof Evaluatable))
			return false;
		const a = o.actualEvaluatable;
		if (!(a instanceof Connective) || this.connector !== a.connector || this.operands.length !== a.operands.length)
			return false;
		const operands = this.operands, aOperands = a.operands;
		for (let i = operands.length - 1; i >= 0; i--) {
			if (!operands[i].equals(aOperands[i]))
				return false;
		}
		return true;
	}
	computeString(simplified) {
		const operands = (simplified ? this.operands : this.originalOperands), connector = this.connector, operandsLength = operands.length;
		let s = operands[0].toString(simplified);
		for (let i = 1; i < operandsLength; i++)
			s += connector + operands[i].toString(simplified);
		return s;
	}
	generateNextSequence(counters, maxValue, size) {
		let positionFromLast = 0, i = size - 1;
		while (i >= 0) {
			counters[i]++;
			if (counters[i] <= (maxValue - positionFromLast))
				break;
			i--;
			positionFromLast++;
		}
		if (i < 0)
			return false;
		while (++i < size)
			counters[i] = counters[i - 1] + 1;
		return true;
	}
	checkIfAxiomIsOfInterest(axiom) {
		if (this.axiomsOfInterest.has(axiom.id))
			return;
		const evaluatable = axiom.evaluatable, evaluatableUsedVariables = evaluatable.usedVariables;
		let operands = this.operands, operandsLength = operands.length;
		for (let i = operandsLength - 1; i >= 0; i--)
			operands[i].checkIfAxiomIsOfInterest(axiom);
		if (!this.usedVariables.containsSubset(evaluatableUsedVariables))
			return;
		for (let i = operandsLength - 1; i >= 0; i--) {
			const equivalence = operands[i].isEquivalentSomehow(evaluatable);
			if (equivalence) {
				this.axiomsOfInterest.set(axiom.id, {
					operands: [operands[i]],
					equivalence,
					axiom
				});
				return;
			}
		}
		if (operandsLength < 2)
			return;
		operands = operands.slice();
		for (let i = operandsLength - 1; i >= 0; i--) {
			if (!operands[i].usedVariables.intersects(evaluatableUsedVariables))
				operands.splice(i, 1);
		}
		operandsLength = operands.length;
		if (operandsLength < 2)
			return;
		const factoryMethod = ((this instanceof Conjunction) ? Conjunction.create : Disjunction.create), maxSize = operandsLength, maxIndex = operandsLength - 1, counters = new Array(maxSize), idSet = new IdSet();
		for (let size = 2; size <= maxSize; size++) {
			for (let i = size - 1; i >= 0; i--)
				counters[i] = i;
			do {
				idSet.clear();
				for (let i = size - 1; i >= 0; i--)
					idSet.addSubset(operands[counters[i]].usedVariables);
				if (!idSet.containsSameElements(evaluatableUsedVariables))
					continue;
				const newOperands = new Array(size);
				for (let i = size - 1; i >= 0; i--)
					newOperands[i] = operands[counters[i]];
				const equivalence = factoryMethod(newOperands, true).isEquivalentSomehow(evaluatable);
				if (equivalence) {
					this.axiomsOfInterest.set(axiom.id, {
						operands: newOperands,
						equivalence,
						axiom
					});
					return;
				}
			} while (this.generateNextSequence(counters, maxIndex, size));
		}
	}
	collectVariables(usedVariables) {
		const operands = this.operands;
		for (let i = operands.length - 1; i >= 0; i--)
			operands[i].collectVariables(usedVariables);
	}
	getAxiomOfInterest(axiom) {
		return this.axiomsOfInterest.get(axiom.id) || null;
	}
}
class Biconditional extends Evaluatable {
	constructor(operandA, operandB) {
		super(false);
		this.operandA = (operandA.isUnary ? operandA : new SubExpression(operandA));
		this.operandB = (operandB.isUnary ? operandB : new SubExpression(operandB));
	}
	equals(o) {
		if (!(o instanceof Evaluatable))
			return false;
		const a = o.actualEvaluatable;
		return ((a instanceof Biconditional) && this.operandA.equals(a.operandA) && this.operandB.equals(a.operandB));
	}
	computeString(simplified) {
		return this.operandA.toString(simplified) + TokenStrings.BiconditionalSpace + this.operandB.toString(simplified);
	}
	checkIfAxiomIsOfInterest(axiom) {
	}
	collectVariables(usedVariables) {
	}
	evaluateEquivalence() {
		return false;
	}
	evaluateValueInternal() {
		return null;
	}
}
class Conjunction extends Connective {
	static create(operands, skipSort) {
		const evaluatable = new Conjunction(operands, skipSort);
		return ((evaluatable.operands.length === 1) ? evaluatable.operands[0] : evaluatable);
	}
	constructor(operands, skipSort) {
		super(operands, skipSort, TokenStrings.ConjunctionSpace, Conjunction);
	}
	evaluateEquivalence() {
		const operands = this.operands;
		for (let i = 0; i < operands.length; i++) {
			if (!operands[i].evaluateEquivalence())
				return false;
		}
		return true;
	}
	evaluateValueInternal() {
		const operands = this.operands, unusedVariables = this.usedVariables.createIdSet();
		let r = true;
		for (let i = operands.length - 1; i >= 0; i--) {
			const v = operands[i].evaluateValue();
			if (v === null)
				continue;
			unusedVariables.deleteSubset(operands[i].usedVariables);
			if (!v) {
				r = false;
			}
		}
		if (!r || !unusedVariables.size)
			return r;
		const axiomsOfInterest = this.axiomsOfInterest;
		for (let axiomOfInterest of axiomsOfInterest.values()) {
			const evaluatable = axiomOfInterest.axiom.evaluatable;
			unusedVariables.deleteSubset(evaluatable.usedVariables);
			if (axiomOfInterest.equivalence < 0) {
				r = false;
				break;
			}
			if (!unusedVariables.size)
				break;
		}
		return (!r ? !r : (unusedVariables.size ? null : true));
	}
}
class Disjunction extends Connective {
	static create(operands, skipSort) {
		const evaluatable = new Disjunction(operands, skipSort);
		return ((evaluatable.operands.length === 1) ? evaluatable.operands[0] : evaluatable);
	}
	constructor(operands, skipSort) {
		super(operands, skipSort, TokenStrings.DisjunctionSpace, Disjunction);
	}
	evaluateEquivalence() {
		const operands = this.operands;
		for (let i = 0; i < operands.length; i++) {
			if (operands[i].evaluateEquivalence())
				return true;
		}
		return false;
	}
	evaluateValueInternal() {
		const operands = this.operands, unusedVariables = this.usedVariables.createIdSet();
		let r = false;
		for (let i = operands.length - 1; i >= 0; i--) {
			const v = operands[i].evaluateValue();
			if (v === null)
				continue;
			unusedVariables.deleteSubset(operands[i].usedVariables);
			if (v) {
				r = true;
			}
		}
		if (r || !unusedVariables.size)
			return r;
		const axiomsOfInterest = this.axiomsOfInterest;
		for (let axiomOfInterest of axiomsOfInterest.values()) {
			const evaluatable = axiomOfInterest.axiom.evaluatable;
			unusedVariables.deleteSubset(evaluatable.usedVariables);
			if (axiomOfInterest.equivalence > 0) {
				r = true;
				break;
			}
			if (!unusedVariables.size)
				break;
		}
		return (r ? r : (unusedVariables.size ? null : false));
	}
}
class Implication extends Evaluatable {
	constructor(operandA, operandB) {
		super(false);
		this.operandA = (operandA.isUnary ? operandA : new SubExpression(operandA));
		this.operandB = (operandB.isUnary ? operandB : new SubExpression(operandB));
		this.axiomOfInterest = null;
	}
	equals(o) {
		if (!(o instanceof Evaluatable))
			return false;
		const a = o.actualEvaluatable;
		return ((a instanceof Implication) && this.operandA.equals(a.operandA) && this.operandB.equals(a.operandB));
	}
	computeString(simplified) {
		return this.operandA.toString(simplified) + TokenStrings.ImplicationSpace + this.operandB.toString(simplified);
	}
	checkIfAxiomIsOfInterest(axiom) {
		if (!this.axiomOfInterest) {
			const equivalence = axiom.evaluatable.isEquivalentSomehow(this);
			if (equivalence) {
				this.axiomOfInterest = {
					operands: null,
					equivalence,
					axiom
				};
			}
		}
		this.operandA.checkIfAxiomIsOfInterest(axiom);
		this.operandB.checkIfAxiomIsOfInterest(axiom);
	}
	collectVariables(usedVariables) {
		this.operandA.collectVariables(usedVariables);
		this.operandB.collectVariables(usedVariables);
	}
	evaluateEquivalence() {
		return (!this.operandA.evaluateEquivalence() || this.operandB.evaluateEquivalence());
	}
	evaluateValueInternal() {
		let internalResult = this.operandA.evaluateValue();
		const b = this.operandB.evaluateValue();
		if (internalResult !== null && b !== null) {
			internalResult = !internalResult || b;
			if (this.axiomOfInterest && internalResult !== (this.axiomOfInterest.equivalence > 0))
				throw new Error(Strings.ErrorInconsistentExpression + this.toString() + Strings.ErrorInconsistentExpression2 + (this.axiomOfInterest.equivalence > 0 ? Strings.True : Strings.False) + +Strings.ErrorInconsistentExpression3because + this.axiomOfInterest.axiom.id + Strings.ErrorInconsistentExpression3 + (internalResult ? Strings.True : Strings.False));
			return internalResult;
		}
		return (this.axiomOfInterest ? (this.axiomOfInterest.equivalence > 0) : internalResult);
	}
}
class Negation extends Evaluatable {
	constructor(evaluatable) {
		super(true);
		const actualEvaluatable = evaluatable.actualEvaluatable;
		this.evaluatable = (actualEvaluatable.isUnary ? actualEvaluatable : new SubExpression(actualEvaluatable));
	}
	equals(o) {
		if (!(o instanceof Evaluatable))
			return false;
		const a = o.actualEvaluatable;
		return ((a instanceof Negation) && this.evaluatable.equals(a.evaluatable));
	}
	computeString(simplified) {
		return TokenStrings.Negation + this.evaluatable.toString(simplified);
	}
	checkIfAxiomIsOfInterest(axiom) {
		this.evaluatable.checkIfAxiomIsOfInterest(axiom);
	}
	collectVariables(usedVariables) {
		this.evaluatable.collectVariables(usedVariables);
	}
	evaluateEquivalence() {
		return !this.evaluatable.evaluateEquivalence();
	}
	evaluateValueInternal() {
		const evaluatedValue = this.evaluatable.evaluateValue();
		return (evaluatedValue === null ? null : !evaluatedValue);
	}
	get usedVariables() {
		return this.evaluatable.usedVariables;
	}
	get sortedVariables() {
		return this.evaluatable.sortedVariables;
	}
}
class BlobDownloader {
	static alertNotSupported() {
		alert(Strings.BrowserNotSupported);
		return false;
	}
	static download(filename, blob) {
		if (!BlobDownloader.supported)
			return false;
		if (BlobDownloader.blobURL) {
			URL.revokeObjectURL(BlobDownloader.blobURL);
			BlobDownloader.blobURL = null;
		}
		if (BlobDownloader.saveAs) {
			try {
				BlobDownloader.saveAs.call(window.navigator, blob, filename);
				return true;
			}
			catch (ex) {
			}
		}
		const a = document.createElement("a");
		BlobDownloader.blobURL = URL.createObjectURL(blob);
		a.href = BlobDownloader.blobURL;
		a.download = filename;
		if (document.createEvent && (window.MouseEvent || window.MouseEvents)) {
			try {
				const evt = document.createEvent("MouseEvents");
				evt.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
				a.dispatchEvent(evt);
				return true;
			}
			catch (ex) {
			}
		}
		a.click();
		return true;
	}
}
BlobDownloader.blobURL = null;
BlobDownloader.saveAs = (window.saveAs || window.webkitSaveAs || window.mozSaveAs || window.msSaveAs || window.navigator.saveBlob || window.navigator.webkitSaveBlob || window.navigator.mozSaveBlob || window.navigator.msSaveBlob);
BlobDownloader.supported = (("Blob" in window) && ("URL" in window) && ("createObjectURL" in window.URL) && ("revokeObjectURL" in window.URL));
;
Strings.init();
Rule.init();
class UI {
	static createSession(contents) {
		const session = window.ace.createEditSession(contents);
		session.setMode("ace/mode/predicate");
		session.setTabSize(4);
		session.setUseSoftTabs(false);
		session.setUseWrapMode(UI.wrapMode);
		session.getUndoManager().reset();
		return session;
	}
	static fixDarkTheme() {
		let bgColor = null, style = document.getElementById("style-dark-mode"), metaColorScheme = document.getElementById("metaColorScheme");
		switch (UI.theme) {
			case "ace/theme/dracula":
				bgColor = "#282a36";
				break;
			case "ace/theme/mono_industrial":
				bgColor = "#222c28";
				break;
			case "ace/theme/monokai":
				bgColor = "#272822";
				break;
		}
		const editorImgLogoGit = document.getElementById("editorImgLogoGit");
		if (bgColor) {
			document.body.style.backgroundColor = bgColor;
			editorImgLogoGit.setAttribute("src", "assets/images/logo-github-w.png?1");
			if (metaColorScheme)
				metaColorScheme.setAttribute("content", "dark");
			if (!style) {
				style = document.createElement("link");
				style.setAttribute("id", "style-dark-mode");
				style.setAttribute("rel", "stylesheet");
				style.setAttribute("href", "assets/css/style-dark.css?v=1.0.2");
				document.head.appendChild(style);
			}
		}
		else {
			document.body.style.backgroundColor = "";
			editorImgLogoGit.setAttribute("src", "assets/images/logo-github.png?1");
			if (metaColorScheme)
				metaColorScheme.setAttribute("content", "light");
			if (style)
				document.head.removeChild(style);
		}
	}
	static modalSaveShown() {
		UI.modalSaveFileName.focus();
	}
	static modalThemeShown() {
		UI.modalThemeSelect.focus();
	}
	static modalSaveFileNameKeyDown(e) {
		if (e.key === "Enter" || e.keyCode === 13)
			UI.modalSaveOk.click();
	}
	static editorActionFileLoadChange() {
		if (UI.loading) {
			UI.editorActionFileLoad.value = "";
			return;
		}
		if (!("files" in UI.editorActionFileLoad)) {
			alert(Strings.ErrorNoFile);
			return;
		}
		let file;
		if (!UI.editorActionFileLoad.files || !UI.editorActionFileLoad.files.length || !(file = UI.editorActionFileLoad.files[0])) {
			UI.editorActionFileLoad.value = "";
			return;
		}
		if (!file.name.toLowerCase().endsWith(".txt")) {
			UI.editorActionFileLoad.value = "";
			alert(Strings.ErrorInvalidFileName);
			return;
		}
		UI.stop();
		UI.loading = true;
		function showError() {
			UI.loading = false;
			UI.editorActionFileLoad.value = "";
			alert(Strings.ErrorFileLoad);
		}
		try {
			const reader = new FileReader();
			reader.onerror = showError;
			reader.onload = function () {
				UI.loading = false;
				UI.editorActionFileLoad.value = "";
				UI.editSession.setValue(reader.result);
			};
			reader.readAsText(file);
		}
		catch (ex) {
			showError();
		}
	}
	static prepareSW() {
		if ("serviceWorker" in navigator) {
			window.addEventListener("beforeinstallprompt", function (e) {
				if ("preventDefault" in e)
					e.preventDefault();
				UI.installationPrompt = e;
				document.getElementById("editorActionInstallSeparator").style.display = "";
				document.getElementById("editorActionInstallItem").style.display = "";
			});
			navigator.serviceWorker.register("/labs-predicate/sw.js");
		}
	}
	static init() {
		if (!("localStorage" in window) || !BlobDownloader.supported)
			BlobDownloader.alertNotSupported();
		UI.prepareSW();
		UI.theme = localStorage.getItem("theme") || "ace/theme/labs";
		UI.fixDarkTheme();
		UI.editor.setOptions({
			selectionStyle: "text",
			highlightActiveLine: true,
			highlightSelectedWord: true,
			readOnly: false,
			cursorStyle: "ace",
			mergeUndoDeltas: true,
			behavioursEnabled: false,
			wrapBehavioursEnabled: false,
			autoScrollEditorIntoView: false,
			copyWithEmptySelection: false,
			useSoftTabs: false,
			navigateWithinSoftTabs: false,
			enableMultiselect: true,
			hScrollBarAlwaysVisible: false,
			vScrollBarAlwaysVisible: false,
			highlightGutterLine: true,
			animatedScroll: false,
			showInvisibles: false,
			showPrintMargin: false,
			fadeFoldWidgets: false,
			showFoldWidgets: true,
			showLineNumbers: true,
			showGutter: true,
			displayIndentGuides: false,
			scrollPastEnd: false,
			fixedWidthGutter: true,
			theme: UI.theme,
			enableLiveAutocompletion: false,
			keyboardHandler: "ace/keyboard/labs"
		});
		$("#modalSave").on("shown.bs.modal", UI.modalSaveShown);
		$("#modalTheme").on("shown.bs.modal", UI.modalThemeShown);
		UI.modalSaveFileName.onkeydown = UI.modalSaveFileNameKeyDown;
		UI.editorActionFileLoad.onchange = UI.editorActionFileLoadChange;
		setTimeout(function () {
			document.body.style.visibility = "";
			UI.editSession = UI.createSession(localStorage.getItem("code") || "");
			UI.stepSession = UI.createSession("");
			if (localStorage.getItem("wrapMode"))
				UI.toggleWrapMode(false);
			UI.editor.setSession(UI.editSession);
			UI.editor.focus();
			UI.editor.resize();
		}, 250);
	}
	static step() {
		if (UI.steppingFinished || UI.loading)
			return;
		if (!UI.stepping) {
			const code = UI.editSession.getValue();
			localStorage.setItem("code", code);
			let error = null;
			try {
				UI.axiomContext = Parser.parse(code);
			}
			catch (ex) {
				error = (("formatMessage" in ex) ? ex.formatMessage() : (ex.message || ex.toString()));
			}
			UI.stepSession.setValue(code + "\n####################" + (error ? ("\n\n# " + Strings.Oops + "\n# " + error) : ""));
			UI.stepSession.getUndoManager().reset();
			UI.btnStop.style.display = "";
			UI.editor.setReadOnly(true);
			UI.stepping = true;
			UI.steppingFinished = !!error;
			UI.editor.setSession(UI.stepSession);
			if (error)
				return;
		}
		try {
			const deduction = UI.axiomContext.step();
			if (deduction) {
				let code = UI.stepSession.getValue();
				if (deduction.error) {
					code += "\n\n# " + Strings.Oops + "\n# " + deduction.text;
					UI.steppingFinished = true;
				}
				else {
					code += "\n\n" + deduction.text + " # " + deduction.explanation;
				}
				UI.stepSession.setValue(code);
			}
			else {
				UI.steppingFinished = true;
			}
			if (UI.steppingFinished && (!deduction || !deduction.error))
				UI.stepSession.setValue(UI.stepSession.getValue() + "\n\n# " + Strings.ICouldNotDeductAnythingElse);
		}
		catch (ex) {
			const error = (("formatMessage" in ex) ? ex.formatMessage() : (ex.message || ex.toString()));
			UI.steppingFinished = true;
			UI.stepSession.setValue(UI.stepSession.getValue() + "\n\n# " + Strings.Oops + "\n# " + error);
		}
	}
	static stop() {
		if (!UI.stepping || UI.loading)
			return;
		UI.btnStop.style.display = "none";
		UI.editor.setReadOnly(false);
		UI.stepping = false;
		UI.steppingFinished = false;
		UI.editor.setSession(UI.editSession);
	}
	static clear() {
		if (UI.loading)
			return;
		UI.stop();
		UI.editSession.setValue("");
	}
	static load() {
		if (UI.loading)
			return;
		UI.editorActionFileLoad.click();
	}
	static showModalSave() {
		if (UI.loading)
			return;
		UI.stop();
		$("#modalSave").modal({
			keyboard: true,
			backdrop: true
		});
	}
	static save() {
		if (UI.loading)
			return;
		let filename = UI.modalSaveFileName.value.trim();
		if (!filename)
			return;
		const code = UI.editSession.getValue() || "\n";
		if (!filename.toLowerCase().endsWith(".txt"))
			filename += ".txt";
		BlobDownloader.download(filename, new Blob([
			new Uint8Array([0xEF, 0xBB, 0xBF]),
			code,
		], { type: "text/plain;charset=utf-8" }));
		$("#modalSave").modal("hide");
	}
	static loadExample() {
		if (UI.loading)
			return;
	}
	static install() {
		document.getElementById("editorActionInstallSeparator").style.display = "none";
		document.getElementById("editorActionInstallItem").style.display = "none";
		if (UI.installationPrompt) {
			try {
				UI.installationPrompt.prompt();
			}
			catch (ex) {
			}
			UI.installationPrompt = null;
		}
	}
	static toggleWrapMode(fromUser) {
		UI.wrapMode = !UI.wrapMode;
		if (fromUser) {
			if (UI.wrapMode)
				localStorage.setItem("wrapMode", "1");
			else
				localStorage.removeItem("wrapMode");
		}
		UI.editorActionToggleWrapModeIcon.className = (UI.wrapMode ? "fa fa-margin fa-check-square-o" : "fa fa-margin fa-square-o");
		UI.editSession.setUseWrapMode(UI.wrapMode);
		UI.stepSession.setUseWrapMode(UI.wrapMode);
	}
	static showModalTheme() {
		UI.modalThemeSelect.value = UI.theme;
		$("#modalTheme").modal({
			keyboard: true,
			backdrop: true
		});
	}
	static setTheme() {
		UI.theme = UI.modalThemeSelect.value;
		localStorage.setItem("theme", UI.theme);
		UI.editor.setTheme(UI.theme);
		UI.fixDarkTheme();
		$("#modalTheme").modal("hide");
	}
}
UI.btnStep = document.getElementById("btnStep");
UI.btnStop = document.getElementById("btnStop");
UI.modalSaveFileName = document.getElementById("modalSaveFileName");
UI.modalSaveOk = document.getElementById("modalSaveOk");
UI.editorActionToggleWrapModeIcon = document.getElementById("editorActionToggleWrapModeIcon");
UI.modalThemeSelect = document.getElementById("modalThemeSelect");
UI.editorActionFileLoad = document.getElementById("editorActionFileLoad");
UI.editor = window.ace.edit("editor");
UI.installationPrompt = null;
UI.loading = false;
UI.stepping = false;
UI.steppingFinished = false;
UI.init();
